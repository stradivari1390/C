//----------------------------------------------------------------------------------------------    
#include <iostream> 
typedef unsigned int WORD ; 

using namespace std ; 

const MaxN = 101 ; 

struct List { 
   List (){} ; 
   List ( int _V , List * _next ) { V = _V ; next =  _next ;} 
   List * next  ; 
   int V ; 
}; 

int    e[MaxN];            // Избыток 
int    h[MaxN];            // Высота вершины 
int    f[MaxN][MaxN];         // Текущее значение предпотока 
int    c[MaxN][MaxN];         // Пропускные способности ребер 

//List L ;               // все вернины V[G]\{s,t} 
//List N[MaxN] ;            // список связности     
List *head[MaxN] , *current[MaxN] , *headL , *pre; 

int  n , m , s = 1,  t , minH ;      // s -  исток , t- сток 

//----------------------------------------------------------------------------------------------    
 void ConstructL(){            // В списке L  хранятся все вершины кроме s,t 
               // т.е V[G]\{s,t} 
      List *cur  ; 
      List * t = new List (2 , NULL ); 
      pre = headL = t ; cur = t ; 
      for (int i = 3 ; i < n ; i++ ) 
      { 
         List *t  = new List ( i , NULL) ; 
         cur->next = t ; 
         cur = cur->next ; 
      } 
 } 
//----------------------------------------------------------------------------------------------    
 int min (int a , int b ){ 
    return a<b ? a:b ; 
 } 
//----------------------------------------------------------------------------------------------                                       // перемещаем вершину в начало 
 void MoveToFront ( List *u ) { 
    
   if ( pre == u )return ; 

   pre->next = u->next ; 

   List * t = new List (u->V , headL ) ; 
   pre = headL = t ; 

   delete u ;       
 } 
//----------------------------------------------------------------------------------------------    
               // Инициализируем предпоток 
 void Initilize_PreFlow () {    
               // здесь ндеюсь всё понятно 
    h[s] = n ; 
    for (int u = 1 ; u <= n ; u++ ){ 
       if ( c[s][u] > 0 ){ 
          f[s][u] =  c[s][u] ; 
          f[u][s] = -c[s][u] ; 
          e[u] = c[s][u]; 
       } 
    } 
 } 
//----------------------------------------------------------------------------------------------                               
               // Проталкиваем поток т.е в вершине u есть избыток 
 void Push (int u , int v ){         // и нам надо протолкнуть поток дальше 

    int d = min (e[u] , c[u][v]-f[u][v]); 
    
    f[u][v] =  f[u][v] + d ;        // увеличиваем поток по ребру (u,v) 
    f[v][u] = -f[u][v] ; 

    e[u] = e[u] - d ;             
    e[v] = e[v] + d ; 
 } 
 //----------------------------------------------------------------------------------------------    
                 //  поднимаем вершину чтоб протолкнут поток 
 void Lift ( int u ) {              //  т.к проталкивать можно только из вешин большей высоты 
    minH = 100000 ; 
   List *v = head[u];           //просматриваем все вершины в остаточной сети и поднимаем даную 
   while (v){              // так чтоб она стала на 1 выше самой низкой 
      if (minH > h[v->V] && c[u][v->V]-f[u][v->V] > 0 )minH = h[v->V]; 
      v =  v->next ; 
   } 
   h[u] = ( minH +1 ) ; 
 } 
//----------------------------------------------------------------------------------------------    
 void Discharge ( int u ){         // разгрузка вершины 
    while ( e[u] > 0 ){         // нока есть избыток        
       List* v = current[u]; 
       if ( current[u] == NULL ){ 
          Lift ( u );            // поднимаем вершину 
          current[u] = head[u]; 
       }                                                                   
       else if ( c[u][v->V]-f[u][v->V] > 0 && h[u] == h[v->V] + 1) 
          Push (u , v->V );      // нашли допустимое ребро и протолкнули поток 
       else current[u] = current[u]->next ;   // переходим к следующему элементу 
    } 
 } 
//----------------------------------------------------------------------------------------------    
 void Lift_To_Front (){ 

   Initilize_PreFlow() ;          // Формируем начальные предпоток 
   ConstructL() ; 

   for (int i = 2 ; i < n ; i++ )       // s == 1 , t == n 
      current[i] = head[i]; 

   List *u = headL ; 

   while ( u != NULL ){                
      int old_height  = h[u->V]; 

      Discharge( u->V );       // Разгружаем вершину u 

      if ( h[u->V] > old_height ){    // если вершина было поднята то 
         MoveToFront ( u );   // перемещаем её в начало списка 
         u = headL; 
      } 
      pre = u ; 
      u = u->next ;       // переходим к следующей вершине 
   } 
   // при выходе из процедуры все объекты созданые оператор new надо 
   // удалить за не надобностью , мне влом оставляю это вам :) 
 } 
//------------------------------------------------------------------------------------------------ 
 int main () { 
    
   cin >> n >> m ;         // здесь n - количество вершин m - количество рёбер 
   int a , b , cf ;         // ..пропускная способность ребра (a,b) == cf 
   for (int i = 0 ; i < m ; i++ ) 
   { 
       cin >> a >> b >> cf ; 
       c[a][b] = cf; 
   } 
               //.. для каждой вершины u Є V строим одностороний список 
    for (int i = 1 ; i <= n ; i++ ){        // соседеё вершина v находится в этом списке ели 
       List *cur ;      // (u,v) Є E лил (v,u) Є E 
       int w = 0 ; 
       for (int j = 1 ; j <= n ; j ++ ){ 
          if ( c[i][j] > 0 || c[j][i] > 0 ){ 
            List * t = new List( j , NULL ) ; 
            if (!w){ 
               head[i] = t ; 
               cur = t ; 
               w = 1 ; 
            } 
            else { 
               cur->next = t ; 
               cur = cur->next ; 
            } 
          }                    
       } 
    } 

Lift_To_Front (); 
               // в масиве f имеем поток 
int sum = 0 ; 
for (int i = 1 ; i <= n ; i++ ) 
   sum +=  f[i][n]; 

   cout << sum ; 
    return 0 ; 
 } 
 //------------------------------------------------------------------------------------------------